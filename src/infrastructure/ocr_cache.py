"""\nSistema de caché para resultados OCR y LLM.\n\nImplementa un sistema de caché persistente y en memoria para\nresultados de OCR y refinamiento LLM, mejorando el rendimiento\ny reduciendo llamadas a APIs externas.\n"""\nimport hashlib\nimport json\nimport os\nfrom functools import lru_cache\nfrom pathlib import Path\nfrom typing import Dict, Optional, Any\nfrom PIL import Image\nimport numpy as np\n\nclass OCRCache:\n    def __init__(self, cache_dir: Optional[Path] = None):\n        """\n        Inicializa el sistema de caché OCR.\n        \n        Args:\n            cache_dir: Directorio para almacenar caché persistente.\n                      Si es None, usa 'data/cache/ocr'.\n        """\n        self.cache_dir = cache_dir or Path('data/cache/ocr')\n        self.cache_dir.mkdir(parents=True, exist_ok=True)\n        self.memory_cache: Dict[str, str] = {}\n    \n    @lru_cache(maxsize=100)\n    def get_image_hash(self, image: Image.Image) -> str:\n        """Genera un hash único para una imagen."""\n        img_array = np.array(image)\n        return hashlib.md5(img_array.tobytes()).hexdigest()\n    \n    def get(self, key: str) -> Optional[str]:\n        """\n        Obtiene un resultado cacheado por su clave.\n        \n        Args:\n            key: Clave única (normalmente hash de imagen)\n            \n        Returns:\n            Contenido cacheado o None si no existe\n        """\n        # Primero buscar en memoria\n        if key in self.memory_cache:\n            return self.memory_cache[key]\n            \n        # Luego buscar en disco\n        cache_file = self.cache_dir / f"{key}.json"\n        if cache_file.exists():\n            try:\n                with open(cache_file, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    self.memory_cache[key] = data['content']  # Actualizar caché en memoria\n                    return data['content']\n            except (json.JSONDecodeError, KeyError, IOError):\n                return None\n                \n        return None\n    \n    def set(self, key: str, value: str) -> None:\n        """\n        Almacena un resultado en la caché.\n        \n        Args:\n            key: Clave única (normalmente hash de imagen)\n            value: Contenido a almacenar\n        """\n        # Guardar en memoria\n        self.memory_cache[key] = value\n        \n        # Guardar en disco\n        cache_file = self.cache_dir / f"{key}.json"\n        data = {\n            'content': value,\n            'timestamp': os.path.getmtime(cache_file) if cache_file.exists() else None\n        }\n        \n        try:\n            with open(cache_file, 'w', encoding='utf-8') as f:\n                json.dump(data, f, ensure_ascii=False)\n        except IOError:\n            pass  # Fallar silenciosamente si no se puede escribir\n    \n    def invalidate(self, key: str) -> None:\n        """\n        Invalida una entrada específica de la caché.\n        \n        Args:\n            key: Clave a invalidar\n        """\n        # Eliminar de memoria\n        if key in self.memory_cache:\n            del self.memory_cache[key]\n            \n        # Eliminar de disco\n        cache_file = self.cache_dir / f"{key}.json"\n        if cache_file.exists():\n            try:\n                cache_file.unlink()\n            except IOError:\n                pass  # Fallar silenciosamente\n    \n    def clear(self) -> None:\n        """Limpia toda la caché (memoria y disco)."""\n        # Limpiar memoria\n        self.memory_cache.clear()\n        self.get_image_hash.cache_clear()\n        \n        # Limpiar disco\n        try:\n            for cache_file in self.cache_dir.glob("*.json"):\n                cache_file.unlink()\n        except (IOError, OSError):\n            pass  # Fallar silenciosamente
